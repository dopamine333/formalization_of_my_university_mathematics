import Mathlib.Logic.ExistsUnique
import Mathlib.Tactic.Choose
import Mathlib.Tactic.Push
import Mathlib.Tactic.Use
import Mathlib.Tactic.NthRewrite
import Mathlib.Data.SProd

class SetTheory (set : Type u) where
  mem : set ‚Üí set ‚Üí Prop

namespace SetTheory

variable {set : Type u} [SetTheory set]

-- notation: ‚àà
instance : Membership set set where
  mem x S := SetTheory.mem x S

def subset (S T : set) : Prop := ‚àÄ x ‚àà S, x ‚àà T

-- notation: ‚äÜ, ‚äá (do not have ‚äÇ, ‚äÉ)
instance : HasSubset set where
  Subset S T := SetTheory.subset S T

example (x S T : set) (hxS : x ‚àà S) (hST : S ‚äÜ T) : x ‚àà T := hST x hxS

end SetTheory

class AxiomOfExtensionality (set : Type u) [SetTheory set] where
  extensionality : ‚àÄ a b : set, a = b ‚Üî ‚àÄ x, x ‚àà a ‚Üî x ‚àà b

-- let you can write `extensionality` instead of `AxiomOfExtensionality.extensionality`
export AxiomOfExtensionality (extensionality)

namespace AxiomOfExtensionality

variable {set : Type u} [SetTheory set]

theorem subset_refl (S : set) : S ‚äÜ S := fun _ hxS ‚Ü¶ hxS

theorem subset_trans (A B C : set) : A ‚äÜ B ‚Üí B ‚äÜ C ‚Üí A ‚äÜ C := by
  intro hAB hBC x hxA
  exact hBC x (hAB x hxA)

theorem subset_antisymm [AxiomOfExtensionality set] (A B : set) : A ‚äÜ B ‚Üí B ‚äÜ A ‚Üí A = B := by
  intro hAB hBA
  rw [extensionality]
  intro x
  constructor
  . intro hxA
    exact hAB x hxA
  . intro hxB
    exact hBA x hxB

end AxiomOfExtensionality

class HasEmptyset (set : Type u) where
  empty : set

instance (set : Type u) [HasEmptyset set] : EmptyCollection set
  where emptyCollection := HasEmptyset.empty

class AxiomOfEmptyset (set : Type u) [SetTheory set] extends HasEmptyset set where
  not_mem_empty : ‚àÄ x, x ‚àâ (‚àÖ : set)

namespace AxiomOfEmptyset

variable {set : Type u} [SetTheory set] [AxiomOfEmptyset set]

theorem empty_subset (S : set) : ‚àÖ ‚äÜ S := by
  intro x hxempty
  have := not_mem_empty x
  contradiction

theorem empty_unique [AxiomOfExtensionality set] :
  ‚àÉ! S : set, ‚àÄ x, x ‚àâ S := by
  refine ‚ü®‚àÖ, ?_, ?_‚ü©
  . exact not_mem_empty
  . intro y hy
    rw [extensionality]
    intro x
    constructor
    . intro h
      exfalso
      exact hy x h
    . intro h
      exfalso
      exact not_mem_empty x h

end AxiomOfEmptyset

-- let you can write `not_mem_empty` instead of `AxiomOfEmptyset.not_mem_empty`
export AxiomOfEmptyset (not_mem_empty)

class AxiomOfReplacement (set : Type u) [SetTheory set] where
  replacement : (set ‚Üí set ‚Üí Prop) ‚Üí set ‚Üí set
  mem_replacement_iff (P : set ‚Üí set ‚Üí Prop) (U : set) :
    (‚àÄ x, ‚àÉ! y, P x y) ‚Üí (‚àÄ y, y ‚àà replacement P U ‚Üî ‚àÉ x, x ‚àà U ‚àß P x y)

export AxiomOfReplacement (replacement mem_replacement_iff)

class AxiomOfSpecification (set : Type u) [SetTheory set] where
  specification : (set ‚Üí Prop) ‚Üí set ‚Üí set
  mem_specification_iff (P : set ‚Üí Prop) (U : set) :
    ‚àÄ x, x ‚àà specification P U ‚Üî x ‚àà U ‚àß P x

export AxiomOfSpecification (specification mem_specification_iff)

-- Proposition 15.1.1
theorem specification_is_redundant_in_ZFC {set : Type u} [SetTheory set]
  [AxiomOfEmptyset set] [AxiomOfReplacement set] :
  ‚àÄ P : set ‚Üí Prop, ‚àÄ U : set, ‚àÉ S : set, ‚àÄ x, x ‚àà S ‚Üî x ‚àà U ‚àß P x := by
  intro P U
  by_cases h : ‚àÄ x ‚àà U, ¬¨ P x
  . use ‚àÖ
    intro x
    constructor
    . intro h
      exfalso
      exact not_mem_empty x h
    . intro ‚ü®hxU, hPx‚ü©
      exfalso
      exact h x hxU hPx
  . push_neg at h
    choose l hlU hPl using h
    let Q x y := P x ‚àß y = x ‚à® ¬¨ P x ‚àß y = l
    have hQ : ‚àÄ x, ‚àÉ! y, Q x y := by
      intro x
      by_cases h : P x
      . use x
        dsimp
        constructor
        . unfold Q
          left
          exact ‚ü®h, rfl‚ü©
        . intro y hy
          apply hy.elim
          . exact fun h' ‚Ü¶ h'.2
          . exact fun h' ‚Ü¶ (h'.1 h).elim
      . use l
        dsimp
        constructor
        . unfold Q
          right
          exact ‚ü®h, rfl‚ü©
        . intro y hy
          apply hy.elim
          . exact fun h' ‚Ü¶ (h h'.1).elim
          . exact fun h' ‚Ü¶ h'.2
    use replacement Q U
    intro y
    rw [mem_replacement_iff Q U hQ]
    constructor
    . rintro ‚ü®x, hxU, hQxy‚ü©
      apply hQxy.elim
      . rintro ‚ü®hPx, rfl‚ü©
        exact ‚ü®hxU, hPx‚ü©
      . rintro ‚ü®_, rfl‚ü©
        exact ‚ü®hlU, hPl‚ü©
    . rintro ‚ü®hyU, hPy‚ü©
      use y, hyU
      left
      exact ‚ü®hPy, rfl‚ü©


noncomputable instance {set : Type u} [SetTheory set]
  [AxiomOfEmptyset set] [AxiomOfReplacement set] : AxiomOfSpecification set where
  specification P U := Classical.choose (specification_is_redundant_in_ZFC P U)
  mem_specification_iff P U := Classical.choose_spec (specification_is_redundant_in_ZFC P U)

class AxiomOfPowerset (set : Type u) [SetTheory set] where
  powerset : set ‚Üí set
  mem_powerset_iff (S : set) : ‚àÄ T, T ‚àà powerset S ‚Üî T ‚äÜ S

prefix:100 "ùí´ " => AxiomOfPowerset.powerset

export AxiomOfPowerset (powerset mem_powerset_iff)

class HasUnion (set : Type u) where
  union : set ‚Üí set ‚Üí set

instance (set : Type u) [HasUnion set] : Union set where union := HasUnion.union

class AxiomOfUnion (set : Type u) [SetTheory set] extends HasUnion set where
  mem_union_iff (S T : set) : ‚àÄ x, x ‚àà S ‚à™ T ‚Üî x ‚àà S ‚à® x ‚àà T

export AxiomOfUnion (mem_union_iff)

class AxiomOfsUnion (set : Type u) [SetTheory set] where
  sUnion : set ‚Üí set
  mem_sUnion_iff (S : set) : ‚àÄ x, x ‚àà sUnion S ‚Üî ‚àÉ A ‚àà S, x ‚àà A

prefix:110 "‚ãÉ‚ÇÄ " => AxiomOfsUnion.sUnion

class HasInter (set : Type u) where
  inter : set ‚Üí set ‚Üí set

instance (set : Type u) [HasInter set] : Inter set where inter := HasInter.inter

class AxiomOfInter (set : Type u) [SetTheory set] extends HasInter set  where
  mem_inter_iff (S T : set) : ‚àÄ x, x ‚àà S ‚à© T ‚Üî x ‚àà S ‚àß x ‚àà T

export AxiomOfInter (mem_inter_iff)

class AxiomOfsInter (set : Type u) [SetTheory set] where
  sInter : set ‚Üí set
  mem_sInter_iff (S : set) : ‚àÄ x, x ‚àà sInter S ‚Üî ‚àÄ A ‚àà S, x ‚àà A

prefix:110 "‚à©‚ÇÄ " => AxiomOfsInter.sInter

class HasSingleton (set : Type u) where
  singleton : set ‚Üí set

instance (set : Type u) [HasSingleton set] : Singleton set set where singleton := HasSingleton.singleton

class AxiomOfSingleton (set : Type u) [SetTheory set] extends HasSingleton set where
  mem_singleton_iff (x : set) : ‚àÄ y, y ‚àà ({x} : set) ‚Üî y = x

export AxiomOfSingleton (mem_singleton_iff)

class AxiomOfInfinity (set : Type u) [SetTheory set]
  [AxiomOfEmptyset set] [AxiomOfUnion set] [AxiomOfSingleton set] where
  infinity : set
  empty_mem_infinity : ‚àÖ ‚àà infinity
  succ_mem_infinity : ‚àÄ x ‚àà infinity, x ‚à™ {x} ‚àà infinity

class AxiomOfRegularity (set : Type u) [SetTheory set]
  [AxiomOfEmptyset set] [AxiomOfInter set] where
  regularity : ‚àÄ S ‚â† (‚àÖ : set), ‚àÉ A ‚àà S, A ‚à© S = ‚àÖ

-- Definition 8.1.1
class HasOrderPair (set : Type u) where
  ordered_pair : set ‚Üí set ‚Üí set

notation :150 "(" a:150 ", " b:150 ")À¢" => HasOrderPair.ordered_pair a b

class AxiomOfOrderedPair (set : Type u) [SetTheory set] extends HasOrderPair set where
  ordered_pair_inj (a b x y : set) : (a, b)À¢ = (x, y)À¢ ‚Üî a = x ‚àß b = y

export AxiomOfOrderedPair (ordered_pair_inj)

class HasProduct (set : Type u) where
  product : set ‚Üí set ‚Üí set

instance (set : Type u) [HasProduct set] : SProd set set set where sprod := HasProduct.product

-- Definition 8.1.2
class AxiomOfProduct (set : Type u) [SetTheory set] [AxiomOfOrderedPair set] extends HasProduct set where
  mem_product_iff (A B : set) : ‚àÄ x, x ‚àà A √óÀ¢ B ‚Üî ‚àÉ a ‚àà A, ‚àÉ b ‚àà B, x = (a, b)À¢

export AxiomOfProduct (mem_product_iff)

section Function

variable {set : Type u} [SetTheory set] [AxiomOfOrderedPair set] [AxiomOfProduct set]

def is_function (A B f : set) : Prop := f ‚äÜ A √óÀ¢ B ‚àß ‚àÄ a ‚àà A, ‚àÉ! b ‚àà B, (a, b)À¢ ‚àà f

noncomputable def toFun
  {A B f : set} (hf : is_function A B f) {a : set} (ha : a ‚àà A) : set :=
  Classical.choose (hf.2 a ha)

theorem toFun_spec
  {A B f : set} (hf : is_function A B f) {a : set} (ha : a ‚àà A) :
  toFun hf ha ‚àà B ‚àß (a, toFun hf ha)À¢ ‚àà f := by
  rw [toFun]
  exact (Classical.choose_spec (hf.2 a ha)).1

theorem toFun_unique
  {A B f : set} (hf : is_function A B f) {a : set} (ha : a ‚àà A)
  {b : set} (hb : b ‚àà B) (habf : (a, b)À¢ ‚àà f) : b = toFun hf ha := by
  rw [toFun]
  have := (Classical.choose_spec (hf.2 a ha)).2
  exact this b ‚ü®hb, habf‚ü©

theorem toFun_ext [AxiomOfExtensionality set]
  {A B f g : set} (hf : is_function A B f) (hg : is_function A B g)
  : f = g ‚Üî ‚àÄ a, (ha : a ‚àà A) ‚Üí toFun hf ha = toFun hg ha := by
  constructor
  . intro heq a ha
    have h1 := toFun_spec hf ha
    have h2 := toFun_spec hg ha
    nth_rw 2 [heq] at h1
    exact (hg.2 a ha).unique h1 h2
  . intro h
    rw [extensionality]
    intro x
    constructor
    . intro hxf
      have := hf.1 x hxf
      rw [mem_product_iff] at this
      obtain ‚ü®a, ha, b, hb, rfl‚ü© := this
      have := toFun_unique hf ha hb hxf
      rw [this, h]
      exact (toFun_spec hg ha).2
    . intro hxg
      have := hg.1 x hxg
      rw [mem_product_iff] at this
      obtain ‚ü®a, ha, b, hb, rfl‚ü© := this
      have := toFun_unique hg ha hb hxg
      rw [this, ‚Üê h]
      exact (toFun_spec hf ha).2

-- more over, assume axiom of specification, axiom_of_powerset holds
variable [AxiomOfSpecification set] [AxiomOfPowerset set]

def function (A B : set) : set := specification (is_function A B) (ùí´ (A √óÀ¢ B))

theorem mem_function_iff (A B f : set) : f ‚àà function A B ‚Üî is_function A B f := by
  constructor
  . intro h
    rw [function, mem_specification_iff] at h
    exact h.2
  . intro h
    have : f ‚äÜ A √óÀ¢ B := by
      rw [is_function] at h
      exact h.1
    rw [function, mem_specification_iff, mem_powerset_iff]
    exact ‚ü®this, h‚ü©

end Function

class AxiomOfChoice (set : Type u) [SetTheory set]
  [AxiomOfEmptyset set] [AxiomOfOrderedPair set] [AxiomOfProduct set] [AxiomOfPowerset set] where
  choice (S : set) : set -- S ‚Ü¶ (f : ùí´ S ‚Üí S)
  choice_is_function (S : set) (hS : S ‚â† ‚àÖ) : is_function (ùí´ S) S (choice S)
  choice_mem (S : set) (hS : S ‚â† ‚àÖ) : ‚àÄ T, (hT : T ‚àà ùí´ S) ‚Üí T ‚â† ‚àÖ ‚Üí toFun (choice_is_function S hS) hT ‚àà T


instance (set : Type u) [SetTheory set] [AxiomOfSpecification set] : AxiomOfInter set where
  inter S T := specification (. ‚àà T) S
  mem_inter_iff S T := by
    intro x
    change _ ‚àà specification (. ‚àà T) S ‚Üî _
    rw [mem_specification_iff]

instance (set : Type u) [SetTheory set]
  [AxiomOfReplacement set] [AxiomOfEmptyset set] [AxiomOfPowerset set] : AxiomOfSingleton set where
  singleton a := replacement (fun x y ‚Ü¶ y = a) (ùí´ ‚àÖ)
  mem_singleton_iff a := by
    intro y
    change _ ‚àà replacement (fun x y ‚Ü¶ y = a) (ùí´ ‚àÖ) ‚Üî _
    simp [mem_replacement_iff, mem_powerset_iff]
    exact fun _ ‚Ü¶ ‚ü®‚àÖ, AxiomOfEmptyset.empty_subset _‚ü©

instance (set : Type u) [SetTheory set]
  [AxiomOfSingleton set] [AxiomOfUnion set] [AxiomOfExtensionality set] : AxiomOfOrderedPair set where
  ordered_pair a b := {{a}} ‚à™ {{a} ‚à™ {b}}
  ordered_pair_inj a b a' b' := by
    constructor
    case mpr => rintro ‚ü®rfl, rfl‚ü©; rfl
    intro h
    by_cases heq : a = b
    . sorry
    . sorry

instance (set : Type u) [SetTheory set]
  [AxiomOfOrderedPair set] [AxiomOfUnion set] [AxiomOfPowerset set] [AxiomOfSpecification set] : AxiomOfProduct set where
  product A B := specification (fun x ‚Ü¶ ‚àÉ a ‚àà A, ‚àÉ b ‚àà B, x = (a, b)À¢) (ùí´ (ùí´ (A ‚à™ B)))
  mem_product_iff A B := by sorry

class ZFC (set : Type u) [SetTheory set] extends
  AxiomOfExtensionality set,
  AxiomOfEmptyset set,
  AxiomOfReplacement set,
  AxiomOfPowerset set,
  AxiomOfUnion set,
  AxiomOfRegularity set,
  AxiomOfInfinity set,
  AxiomOfChoice set
